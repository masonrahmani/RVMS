// src/components/vulnerabilities/vulnerability-list.tsx
"use client";

import { useState, useEffect, useMemo } from "react";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import {
  Table,
  TableBody,
  TableCaption,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Loader2, Search } from "lucide-react";
import { suggestRiskLevel, SuggestRiskLevelInput, SuggestRiskLevelOutput } from "@/ai/flows/suggest-risk-level";
import { suggestRemediationSteps, SuggestRemediationStepsInput, SuggestRemediationStepsOutput } from "@/ai/flows/suggest-remediation-steps";
import { toast } from "@/hooks/use-toast";

// Define Vulnerability type
interface Vulnerability {
  id: string;
  title: string;
  risk: string;
  description: string;
  suggestedRisk?: string | null; // null = loading, undefined = not fetched
  suggestedRemediation?: string | null; // null = loading, undefined = not fetched
}

const initialVulnerabilities: Vulnerability[] = [
  { id: "1", title: "XSS Vulnerability", risk: "High", description: "A cross-site scripting vulnerability." },
  { id: "2", title: "SQL Injection", risk: "Critical", description: "A SQL injection vulnerability." },
  { id: "3", title: "CSRF Vulnerability", risk: "Medium", description: "A cross-site request forgery vulnerability." },
];

export const VulnerabilityList = () => {
  const [vulnerabilities, setVulnerabilities] = useState<Vulnerability[]>(initialVulnerabilities);
  const [searchQuery, setSearchQuery] = useState("");
  const [isLoadingSuggestions, setIsLoadingSuggestions] = useState(false);

  // Fetch AI suggestions when component mounts or initial data changes
  useEffect(() => {
    const fetchSuggestions = async () => {
      setIsLoadingSuggestions(true);
      try {
        const suggestionsPromises = vulnerabilities.map(async (vuln) => {
          // Fetch both suggestions concurrently for a single vulnerability
          const [riskResult, remediationResult] = await Promise.allSettled([
            suggestRiskLevel({ vulnerabilityDescription: vuln.description }),
            suggestRemediationSteps({ vulnerabilityDescription: vuln.description })
          ]);

          const suggestedRisk = riskResult.status === 'fulfilled' ? riskResult.value.suggestedRiskLevel : 'Error';
          const suggestedRemediation = remediationResult.status === 'fulfilled' ? remediationResult.value.remediationSteps : 'Error fetching remediation';

          return {
            ...vuln,
            suggestedRisk: suggestedRisk,
            suggestedRemediation: suggestedRemediation,
          };
        });

        const updatedVulnerabilities = await Promise.all(suggestionsPromises);
        setVulnerabilities(updatedVulnerabilities);

      } catch (error) {
        console.error("Failed to fetch AI suggestions:", error);
        toast({
          title: "Error",
          description: "Failed to fetch AI suggestions.",
          variant: "destructive",
        });
        // Optionally mark all as error or handle partially
        setVulnerabilities(vulnerabilities.map(v => ({
            ...v,
            suggestedRisk: 'Error',
            suggestedRemediation: 'Error'
        })));
      } finally {
        setIsLoadingSuggestions(false);
      }
    };

    // Check if suggestions are already fetched to avoid re-fetching on every render
    const needsFetching = vulnerabilities.some(v => v.suggestedRisk === undefined || v.suggestedRemediation === undefined);
    if (needsFetching) {
      fetchSuggestions();
    }
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []); // Run only once on mount with initial data

  const filteredVulnerabilities = useMemo(() => {
    return vulnerabilities.filter((vuln) =>
      vuln.title.toLowerCase().includes(searchQuery.toLowerCase()) ||
      vuln.description.toLowerCase().includes(searchQuery.toLowerCase()) ||
      vuln.risk.toLowerCase().includes(searchQuery.toLowerCase()) ||
      (vuln.suggestedRisk && vuln.suggestedRisk.toLowerCase().includes(searchQuery.toLowerCase())) ||
      (vuln.suggestedRemediation && vuln.suggestedRemediation.toLowerCase().includes(searchQuery.toLowerCase()))
    );
  }, [vulnerabilities, searchQuery]);


  const renderCellContent = (content: string | null | undefined) => {
    if (content === null) {
      return <Loader2 className="h-4 w-4 animate-spin text-muted-foreground" />;
    }
    if (content === undefined || content === 'Error') {
        return <span className="text-destructive">Error</span>
    }
    return content;
  }

  return (
    <Card className="w-full">
      <CardHeader>
        <CardTitle>Vulnerabilities</CardTitle>
        <CardDescription>List of vulnerabilities with AI-suggested risk levels and remediation steps.</CardDescription>
      </CardHeader>
      <CardContent>
        <div className="flex items-center justify-between py-2">
          <div className="relative w-full max-w-sm">
             <Search className="absolute left-2.5 top-2.5 h-4 w-4 text-muted-foreground" />
            <Input
              type="text"
              placeholder="Search vulnerabilities..."
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
              className="pl-8" // Add padding for the icon
            />
          </div>
           {isLoadingSuggestions && <Loader2 className="h-5 w-5 animate-spin ml-4" />}
        </div>
        <ScrollArea className="mt-4 border rounded-md">
          <Table className="w-full">
            <TableHeader>
              <TableRow>
                <TableHead>Title</TableHead>
                <TableHead>Description</TableHead>
                <TableHead>Reported Risk</TableHead>
                <TableHead>AI Suggested Risk</TableHead>
                <TableHead>AI Suggested Remediation</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {filteredVulnerabilities.map((vuln) => (
                <TableRow key={vuln.id}>
                  <TableCell className="font-medium">{vuln.title}</TableCell>
                  <TableCell>{vuln.description}</TableCell>
                  <TableCell>{vuln.risk}</TableCell>
                  <TableCell>
                    {renderCellContent(vuln.suggestedRisk)}
                  </TableCell>
                   <TableCell className="text-sm">
                    {renderCellContent(vuln.suggestedRemediation)}
                  </TableCell>
                </TableRow>
              ))}
              {filteredVulnerabilities.length === 0 && !isLoadingSuggestions && (
                <TableRow>
                  <TableCell colSpan={5} className="h-24 text-center">
                    No vulnerabilities found matching your search.
                  </TableCell>
                </TableRow>
              )}
               {isLoadingSuggestions && filteredVulnerabilities.length === 0 && (
                 <TableRow>
                    <TableCell colSpan={5} className="h-24 text-center">
                        <div className="flex justify-center items-center">
                        <Loader2 className="mr-2 h-6 w-6 animate-spin" />
                        <span>Loading AI suggestions...</span>
                        </div>
                    </TableCell>
                    </TableRow>
               )}
            </TableBody>
          </Table>
        </ScrollArea>
      </CardContent>
    </Card>
  );
};
